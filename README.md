# Тестовое задание для Cloud Camp

### Ссылки для быстрой навигации

[- 1. Ответы на вопросы](#answers) </br>
[- 2. HTTP-балансировщик нагрузки на Go](#part1) </br>
[- 3. Rate-Limiting](#part2) </br>
[- 4. Документация к проекту](#doc) </br>
[- 5. Документация к API для добавления/удаления клиентов (IP) и настройки их лимитов.](#api_doc) </br>
[- 6. Результаты нагрузочного тестирования с помощью Apache Bench](#load_test) </br>


## <a name="answers"></a>1. Ответы на вопросы



### Опишите самую интересную задачу в программировании, которую вам приходилось решать?
 > Самая интересная задача в программировании, которую я решал, — это создание аналога TikTok. Я разработал ленту видео, где пользователи могли смотреть короткие ролики, а также добавил интерактивные функции, такие как лайки, комментарии и возможность делиться видео. Было круто разбираться, как сделать приложение удобным и увлекательным, чтобы людям хотелось возвращаться. Пришлось покопаться в работе с видео, оптимизации загрузки и интерфейса, чтобы всё работало плавно. Это был увлекательный вызов, потому что я видел, как мои решения напрямую влияют на опыт пользователей.

### Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?
> Во время работы над приложением-браузером для Android с функцией загрузки видео я случайно вошел в аккаунт разработчика компании в Google Play Console с российского IP-адреса. Я не знал, что это нарушает правила Google из-за ограничений. Через несколько дней компания получила уведомление, что аккаунт заблокирован, а приложение снято с публикации. </br></br>
Мне нужно было разобраться, почему произошла блокировка, и помочь команде восстановить аккаунт, чтобы вернуть приложение в Google Play. Также нужно было найти способ предотвратить такие ошибки в будущем, чтобы безопасно работать с аккаунтом компании.</br></br>
Я начал с анализа письма от Google и выяснил, что блокировка связана с входом с российского IP. Я изучил правила Google Play и форумы разработчиков, чтобы понять причину и возможные шаги. Затем я сообщил команде о своей ошибке и передал всю информацию ASO-специалисту, который занялся подачей апелляции. Чтобы избежать повторения проблемы, я предложил использовать сторонний прокси-браузер для безопасного входа в Google Play Console. Я нашел подходящий прокси-браузер, протестировал его и поделился инструкцией с командой, объяснив, как он помогает обойти ограничения по IP.</br></br>
ASO-специалист успешно подал апелляцию, и через неделю аккаунт компании восстановили. Приложение-браузер с функцией загрузки видео вернулось в Google Play. Команда начала использовать сторонний прокси-браузер для входа в Google Play Console, что исключило риск новых блокировок. Этот случай научил меня тщательно проверять правила платформ и использовать безопасные инструменты для работы с корпоративными аккаунтами. 

### Каковы ваши ожидания от участия в буткемпе?
> Я хочу участвовать в буткемпе, чтобы прокачать свои навыки в Golang и получить реальный опыт работы над продакшен-проектами. В буткемпе я надеюсь научиться писать качественный код на Golang, разобраться, как строятся продакшен-приложения, и понять, как решать задачи в команде. Хочу работать над реальными проектами, получать фидбэк от наставников и учиться у опытных разработчиков. Еще было бы круто освоить новые инструменты и подходы, чтобы в будущем создавать надежные и крутые приложения.

## <a id="part1"></a>2. HTTP-балансировщик нагрузки на Go

### Выполненные пункты
- Реализовал HTTP-сервер, который принимает входящие запросы на порту 8080.
- При получении запроса балансировщик пересылает его на один из заранее заданных (в **.yaml** файле) бэкенд-серверов.
- Использовал стандартный HTTP-пакет Go (**net/http**) для работы с запросами и для переадресации (reverse proxy, с использованием пакета **httputil**).
- Реализовал алгоритм распределения запросов по бэкендам - **RoundRobin**, **LeastConnections**
- Балансировщик  обрабатывает ситуацию, когда один или несколько бэкендов недоступны. Вывожу структурированное сообщение об ошибке если все бэкенды упали, если есть живые , перенаправляю на живой бэкенд
- Обеспечена одновременная обработка нескольких запросов с использованием горутин.
- Гарантирована корректная работа в условиях конкурентных вызовов.
- Реализована обработку ошибок при обращении к бэкендам. Ошибки выводятся в лог
- Реализована логирование входящих запросов, ошибок и событий с использованием **zerolog**
- Балансировщик получает список бэкендов и порт для прослушивания через внешний конфигурационный **YAML**.
- Конфигурация независима от кода.
## <a id="part2"></a>3. Rate-Limiting

### Выполненные пункты
- Каждому клиенту (**IP**) выделяется отдельный bucket токенов.
- Настройки bucket: емкость, скорость пополнения через **YAML** конфиг
- Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.
- Отслеживается состояние каждого клиента с помощью IP
- Поддержка возможности настройки разных лимитов для разных клиентов с помощью API c последующим сохраненим в **Redis**.
- Использование time.Ticker для периодического пополнения токенов в buckets.
- Гарантирована атомарность операций с токенами (проверка, извлечение, пополнение).
- Методы обработки запросов и обновления состояния buckets потокобезопасны.
## <a id="doc"></a>4. Документация к проекту
### <a id="doc_launch"></a>Запуск проекта
Проект можно запустить двумя способами 

#### 1. С помощью Docker
```
docker compose up -d
```
#### 2. Запуск проекта без докера (в корне проекта):
```bash
go mod download
go run ./cmd/
```
#### Запусков тестовых серверов
В проекте есть bash скрипт для запуска тестовых серверов на которые будем перенаправлять траффик
Сервера будут иметь следующие адреса:
- http://127.0.0.1:8081
- http://127.0.0.1:8082
- http://127.0.0.1:8083

Эти хосты уже занесены в конфиг файл (**config.yaml**) 

###### Linux OS:
```bash
.\demo\start_servers.sh
```
#### Настройка конфига
В корне проекта уже лежит готовый пример конфига (**config.yaml**) 

###### Пример с описанием каждой настройки:
```yaml
# Уровень логирования приложения
logger_level: 0
# Настройки сервера
server:
  # Порт, на котором сервер будет принимать запросы
  port: 8080
  # Метод балансировки нагрузки
  # LC - Least Connections (направляет запросы к серверу с наименьшим количеством активных соединений)
  # RR - Round Robin (распределяет запросы по очереди между серверами)
  lb_method: RR
# Настройки ограничения скорости запросов (rate limiter)
rate_limiter:
  # Включение/отключение механизма ограничения скорости
  enabled: true
  # Настройки подключения к базе данных (Redis) для хранения данных rate limiter
  db: 
    # Хост базы данных (например, адрес сервера Redis)
    host: cache
    # Порт для подключения к базе данных
    port: 6379
    # Пароль для аутентификации в базе данных
    password: qwerty123
  # Интервал времени для очистки устаревших buctet'ов в rate limiter
  cleanup_interval: 5m
  # Интервал времени для пополнения токенов в bucket
  refill_interval: 1s
  # Время жизни bucket (после этого времени данные bucket удаляются)
  bucket_expiration: 1h
  # Настройки по умолчанию для клиентов rate limiter
  default:
    # Скорость пополнения токенов (например, 5 токенов в секунду)
    refill_rate: 5
    # Максимальное количество токенов в bucket
    max_tokens: 10 

# Настройки пула серверов для балансировки нагрузки
pool: 
  # Список URL-адресов серверов, на которые будут перенаправляться запросы
  urls:
  - http://127.0.0.1:8081
  - http://127.0.0.1:8082
  - http://127.0.0.1:8083
  # Настройки проверки работоспособности серверов (healthcheck)
  healthcheck: 
    # Таймаут для запроса к endpoint'у проверки работоспособности
    timeout: 2s
    # Путь к endpoint'у, который возвращает статус сервера
    endpoint: /healthcheck
```
### 

## <a id="api_doc"></a>5. Документация к API для добавления/удаления клиентов (IP) и настройки их лимитов.

### 1. Создание или обновление конфигурации ограничения скорости

**POST `/api/ratelimit/config`**

Создаёт или обновляет конфигурацию ограничения скорости для указанного IP-адреса.

Тело запроса:
```json
{
  "ip": "127.0.0.1", // IP-адрес клиента (обязательное поле, непустая строка).
  "max_tokens": 10, // Максимальное количество токенов в бакете (обязательное поле, положительное целое число). 
  "refill_rate": 5 // Количество токенов, добавляемых в секунду (обязательное поле, положительное целое число).
}
```

#### Ответ

Коды статуса: 
- **`200 OK`**: Конфигурация успешно создана или обновлена. 
- **`400 Bad Request`**: Некорректное тело запроса или ошибка валидации. 
- **`500 Internal Server Error`**: Не удалось сохранить конфигурацию. 

#### Тело ответа (при успехе):

```json
{
  "ip": "127.0.0.1",
  "max_tokens": 10,
  "refill_rate": 5
}
```
#### Пример 
```bash
curl -X POST http://localhost:8080/api/ratelimit/config \
  -H "Content-Type: application/json" \
  -d '{"ip":"192.168.1.1","max_tokens":100,"refill_rate":10}'
```

### 2. Получение конфигурации ограничения скорости

**GET `/api/ratelimit/config/{ip}`**

Получает конфигурацию ограничения скорости для указанного IP-адреса.

Параметры пути::
- **`ip`**: IP-адрес клиента **(обязательное поле, непустая строка)**.



#### Ответ

Коды статуса: 
- **`200 OK`**: Конфигурация успешно получена.
- **`400 Bad Request`**: IP-адрес отсутствует или некорректен. 
- **`500 Internal Server Error`**: Не удалось получить конфигурацию. 

#### Тело ответа (при успехе):

```json
{
  "ip": "127.0.0.1",
  "max_tokens": 10,
  "refill_rate": 5
}
```
#### Пример 
```bash
curl http://localhost:8080/api/ratelimit/config/192.168.1.1
```

### 3. Удаление конфигурации ограничения скорости

**DELETE `/api/ratelimit/config/{ip}`**

Удаляет конфигурацию ограничения скорости для указанного IP-адреса и очищает связанный токен-бакет.

Параметры пути::
- **`ip`**: IP-адрес клиента **(обязательное поле, непустая строка)**.



#### Ответ

Коды статуса: 
- **`204 No Content`**: Конфигурация успешно удалена.
- **`400 Bad Request`**: IP-адрес отсутствует или некорректен.
- **`500 Internal Server Error`**: Не удалось удалить конфигурацию.
#### Пример 
```bash
curl -X DELETE http://localhost:8080/api/ratelimit/config/192.168.1.1
```

## <a id="load_test"></a>6. Результаты нагрузочного тестирования с помощью Apache Bench
### Пример результатов нагрузочного тестирования с помощью Apache Bench

```bash 
ab -n 5000 -c 1000 http://localhost:8080/
```

##### Тест выполнялся с выключенный rate-limiter

```bash
Server Software:        
Server Hostname:        localhost
Server Port:            8080

Document Path:          /
Document Length:        42 bytes

Concurrency Level:      1000
Time taken for tests:   0.489 seconds
Complete requests:      5000
Failed requests:        0
Total transferred:      1215000 bytes
HTML transferred:       210000 bytes
Requests per second:    10224.78 [#/sec] (mean)
Time per request:       97.802 [ms] (mean)
Time per request:       0.098 [ms] (mean, across all concurrent requests)
Transfer rate:          2426.39 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    3   4.7      1      17
Processing:     0   87  52.5     80     374
Waiting:        0   86  52.6     80     374
Total:          0   90  52.1     83     374

Percentage of the requests served within a certain time (ms)
  50%     83
  66%    104
  75%    120
  80%    131
  90%    159
  95%    184
  98%    221
  99%    248
 100%    374 (longest request)

```